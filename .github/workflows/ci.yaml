name: CI Pipeline

on: push

jobs:
  # ----------------------------------------------------------------------
  # JOB 1: ML Pipeline Execution (Runs on GitHub-hosted Runner)
  # This job handles code checkout, dependency install, DVC execution, 
  # and MLflow logging, ensuring the model artifacts are created.
  # ----------------------------------------------------------------------
  ml-pipeline-run:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: üì¶ Checkout code
        uses: actions/checkout@v3

      - name: üêç Setup Python 3.12
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: ‚öôÔ∏è Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: üì• Install all dependencies
        run: pip install -r requirements.txt

      - name: üîë Set up DVC and MLflow Tracking Credentials
        env:
          YAHOO: ${{ secrets.YAHOO }}
        run: |
          echo "MLFLOW_TRACKING_USERNAME=$YAHOO" >> $GITHUB_ENV
          echo "MLFLOW_TRACKING_PASSWORD=$YAHOO" >> $GITHUB_ENV

      - name: üèÉ Run DVC Pipeline (`dvc repro`)
        run: dvc repro

  # ----------------------------------------------------------------------
  # JOB 2: Docker Build and Push (Runs on Self-Hosted EC2 Runner)
  # This job handles the heavy Docker build where disk space is constrained.
  # You MUST set up your EC2 instance as a self-hosted runner with this label.
  # ----------------------------------------------------------------------
  docker-build-and-push:
    # CRITICAL: Target the self-hosted runner running on your EC2 instance
    runs-on: self-hosted-ec2
    needs: ml-pipeline-run # Ensure ML pipeline runs first

    steps:
      - name: üì¶ Checkout code
        # Check out code again on the EC2 runner
        uses: actions/checkout@v3
      
      - name: ‚òÅÔ∏è Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
          output-env-credentials: true
          
      - name: üîê Login to AWS ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_DEFAULT_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com

      - name: üê≥ Build Docker image
        # This build will use the ample disk space of your EC2 instance
        run: |
          docker build -t ${{ secrets.ECR_REPO }}:latest .

      - name: üè∑Ô∏è Tag Docker image
        run: |
          docker tag ${{ secrets.ECR_REPO }}:latest \
          ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/${{ secrets.ECR_REPO }}:latest
          
      - name: üöÄ Push Docker image to ECR
        run: |
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/${{ secrets.ECR_REPO }}:latest